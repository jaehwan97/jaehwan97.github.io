# 재귀 알고리즘

## 재귀 알고리즘의 기본

재귀 알고리즘(Recursive Algorithm)은 자신을 호출하여 문제를 해결하는 알고리즘입니다. 이를 간단히 말하면, 어떤 함수가 자기 자신을 호출하여 문제를 해결하는 과정에서 재귀 알고리즘이 사용됩니다.

재귀 알고리즘을 설명하기 위해 예를 들어보겠습니다. 가장 대표적인 예로는 팩토리얼 함수가 있습니다. 팩토리얼 함수는 양의 정수 n에 대해 n!을 구하는 함수로, n!은 1부터 n까지의 정수를 곱한 값입니다. 이를 수식으로 나타내면 n! = 1 x 2 x 3 x ... x n입니다.

이를 재귀 알고리즘으로 구현해보면 다음과 같습니다.

```java
int factorial(int n) {
    if (n == 0) {
        return 1;   // 0! = 1
    }
    else { //n이 0보다 크면
        return n * factorial(n - 1);   // n! = n * (n-1)!
    }
}
```

위의 코드에서 `factorial(n)` 함수는 `n`의 팩토리얼 값을 반환합니다. 함수 내부에서 `n`이 0일 경우, 1을 반환하여 재귀를 멈춥니다. 그렇지 않은 경우, `n`과 `factorial(n - 1)`을 곱한 값을 반환합니다. 이 때, `factorial(n - 1)`은 `n-1`의 팩토리얼 값을 반환하며, 다시 `factorial(n - 2)`를 호출하여 재귀적으로 계산하게 됩니다. 이러한 과정이 `factorial(0)`까지 계산되면, 결과적으로 `n`의 팩토리얼 값이 반환됩니다.

이처럼 재귀 알고리즘은 문제를 작은 단위의 문제로 분할하고, 각각의 문제에 대해 함수를 재귀적으로 호출하여 해결합니다. 이는 복잡한 문제를 간단한 단계로 분할하여 해결하기 위해 유용하게 사용되며, 대표적인 예로는 퀵 정렬, 병합 정렬 등이 있습니다.

직접 재귀와 간접 재귀

직접재귀: 함수가 자기 자신을 호출하는 것. (위 예제)

간접재귀: 두 개 이상의 함수가 서로를 호출하여 재귀적으로 실행되는 경우

```java
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
}

int main() {
    int n = 10;
    for (int i = 0; i < n; i++) {
        printf("%d ", fibonacci(i));
    }
    return 0;
}
```

※공통: 함수가 실행될 때마다 새로운 호출 스택이 생성되어야해서 스택메모리가 많이 사용될 수 있습니다.

## Q1 실습 5-1의 factorial 메서드를 재귀 메서드를 호출을 사용하지 말고 작성하세요.

```java
static int factorial(int n){ //메인에서 받은 n만큼
  int num=1;
  for(int i = n; i > 1; i--){
  	num *= i;  
  }
  return num;
}
```



## Q2 실습 5-2의 gcd메서드를 재귀 메서드 호출을 사용하지 말고 작성하세요.

```java
//유클리드 호제법 두 수의 최대 공약수를 구하는 방법: 두개의 자연수 a와 b에 대해, a를 b로 나눈 나머지를 r이라고 할 때, a와 b의 최대공약수는 b와 r의 최대공약수와 같다는 원리를 이용합니다.
int gcd(int x,int y){
  while(y != 0){ //y가 0이 아닐때까지 반복
    int num=y;// num에 y를 저장
    y= x%y; //y에 x를 y로 나눈 나머지를 저장
    x = num; //x에 기존 y값을 저장
  }
  return x; //반복문이 종료되면 x가 최대 공약수이므로 x를 반환
}

//
```



## Q3 배열 a의 모든 요소의 최대 공약수를 구하는 다음 메서드를 작성하세요.

```java

```



## Q4 다음의 recur2메서드에 대하여 하향식 분석과 상향식 분석을 수행하세요.

```java
static void recur2(int n){
  if(n>0){
    recur2(n-2);
    System.out.println(n);
    recur2(n-1);
  }
}

//상향식: 함수의 호출 순서를 계산 


//하향식:함수가 호출될 때마다 인자와 함께 어떤일이 일어나는지 계산
//0보다 먼저 큰지 판단후 recur(n-2)가 먼저 호출되고, 그 다음에 n을 출력하고, 다시 recur(n-1)를 호출하는 것을 볼 수 있습니다.  recur 함수는 n이 0보다 클 때마다 2씩 감소한 n을 인자로 recur(n-2) 함수를 재귀호출하고, n을 출력하고, n이 1보다 크면 1씩 감소한 n을 인자로 recur(n-1) 함수를 재귀호출합니다. 재귀호출을 반복하다가 n이 0보다 작거나 같아지면 재귀호출을 멈추고 n을 출력합니다.

2 1 4 1 3 2 1 간단히 보면 호출된것 부터 계산하고 다시 돌아와서 계산하고 무한반복
recur2(4)
```



## Q5 실습 5-3과 실습 5-6을 각각 수정하여 메서드 호출 횟수를 카운트해 출력하도록 프로그램을 작성하세요.

```java
int count; //인스턴스 변수
static void recur2(int n){
  count++;
  if(n>0){
    recur2(n-2);
    System.out.println(n);
    recur2(n-1);
  }
}

//하고 count 메인에서 출력
```

